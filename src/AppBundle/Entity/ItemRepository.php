<?php

/*
 * @package ArionCRM
 * @author Isaac Raway <iraway@metasushi [dot] com>
 * @author Antoinette Smith <asmith@metasushi [dot] com>
 * @link http://arioncrm.com/
 * @copyright (c)2015-2022. MetaSushi, LLC. All rights reserved. Your use of this software in any way indicates agreement
 * to the software license available currenty at http://arioncrm.com/ 
 * This open source edition is released under GPL 3.0. available at https://www.gnu.org/licenses/gpl-3.0.en.html
 */

namespace AppBundle\Entity;

use Psr\Log\LoggerInterface;
use Doctrine\ORM\Query\ResultSetMapping;
use Doctrine\ORM\Query\ResultSetMappingBuilder;
use Doctrine\ORM\QueryBuilder;
use AppBundle\Entity\User;
use AppBundle\Fields\Meta\FieldMetaFactory;
use AppBundle\Service\TextMacroService;
use AppBundle\Service\AuthService;

/**
 * ItemRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ItemRepository extends \Doctrine\ORM\EntityRepository
{
    /**
     * @var \Psr\Log\LoggerInterface $logger
     */
    protected $logger;

    /**
     * @var ItemTypeRepository
     */
    protected $itemTypes;

    /**
     * @var ItemValueRepository
     */
    protected $itemValues;

    /**
     * @var FieldRepository
     */
    protected $fields;

    /**
     * @var UserRepository
     */
    protected $users;

    /**
     * @var FieldMetaFactory
     */
    protected $fieldMetaFactory;

    /**
     * @var AppBundle\Service\SiteService
     */
    protected $site;

    /**
     * AuthService
     */
    protected $session;

    private $cache;

    /**
     * Called by service bindings in services.yml instead of __construct, which is needed by
     * Doctrine.
     */
    public function initService(LoggerInterface $logger,
                                ItemTypeRepository $itemTypes,
                                ItemValueRepository $itemValues,
                                UserRepository $users,
                                FieldRepository $fields,
                                FieldMetaFactory $fieldMetaFactory,
                                AuthService $session)
    {
        $this->logger = $logger;
        $this->itemTypes = $itemTypes;
        $this->itemValues = $itemValues;
        $this->users = $users;
        $this->fields = $fields;
        $this->fieldMetaFactory = $fieldMetaFactory;
        $this->session = $session;
    }

    public function setMacroService(TextMacroService $textMacroService)
    {
        $this->textMacroService = $textMacroService;
    }

    public function clearCache()
    {
        $this->cache = [];
    }

    private function addUserFilters(QueryBuilder &$qb, &$where, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId, User $currentUser)
    {
        $isRestrictedUser = $restrictedUserOwnerItemType != 0 || $restrictedUserOwnerItemId != 0;
    
        if($isRestrictedUser)
        {
            // Limit to item types visible to restricted users
            $qb = $qb->leftJoin('items.itemType', 'itemType', \Doctrine\ORM\Query\Expr\Join::WITH, 'itemType.visibleToRestrictedUsers = 1');

            // Limit to items with the same owner as the restricted user, or that owner item itself
            $where->add($qb->expr()->orX(
                $qb->expr()->andX($qb->expr()->eq('items.ownerItemType', $restrictedUserOwnerItemType), $qb->expr()->eq('items.ownerItem', $restrictedUserOwnerItemId)),
                $qb->expr()->andX($qb->expr()->eq('items.itemType', $restrictedUserOwnerItemType), $qb->expr()->eq('items.id', $restrictedUserOwnerItemId))
            ));
        }

        // Is normal user?
        if($currentUser->getUserType() == 'normal') {
            $qb->setParameter(':filterTicketType', '$.type');
            $fieldName = "JSON_EXTRACT(items.itemValues, :filterTicketType)";
            $where->add($qb->expr()->orX($qb->expr()->isNull($fieldName), $qb->expr()->neq($fieldName, $qb->expr()->literal("5"))));
        }
    }
    
    /**
     * Find items from a particular item type, with filters as
     * used in the URL.
     *
     * If restrictedUserOwnerItemType and restrictedUserOwnerItemId are specified, limit result to items that
     * contain a relationship field pointed at the same owner item type, with the same item ID. For instance, 
     * limit items to those that have a Clients relationship field with "Acme Co." client selected as the client.
     *
     * @param integer $accountId  account to find item under
     * @param string $itemTypeName name of item type to search for items from
     * @param array $filters
     * @param string $search search for keyword in item values
     * @param string $sort field name*direction to sort on. Examples: id*desc, dueDate*asc
     * @param int $restrictedUserOwnerItemType
     * @param int $restrictedUserOwnerItemId 
     * @param int $limit number of rows to return
     * @param int $page page of results to fetch, 1 is the first
     *            page
     */
        public function findItems($accountId, $itemTypeName, array $filters=[], $search, $sort,
      $restrictedUserOwnerItemType, $restrictedUserOwnerItemId, $limit, $page)
    {
        $currentUser = $this->session->getUser();
        if(!$currentUser || !is_object($currentUser))
            throw new \InvalidArgumentException('findItems requires active session');


        // DEBUG $this->logger->debug(__METHOD__.'::params::'.json_encode(['accountId' => $accountId, 'itemTypeName' => $itemTypeName, 'filters' => $filters, 'search' => $search,
        // DEBUG                      'restrictedUserOwnerItemType' => $restrictedUserOwnerItemType, 'restrictedUserOwnerItemId' => $restrictedUserOwnerItemId]));
        $cacheKey = 'findItems:'.md5($accountId.':'.$itemTypeName.':'.json_encode($filters).':'.md5($search).':'.
                        $restrictedUserOwnerItemType.':'.$restrictedUserOwnerItemId.':'.$currentUser->getId());
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        if(!$accountId ) 
            throw new \InvalidArgumentException('findItems requires accountId');

        
        if($itemTypeName) {
            if(!is_numeric($itemTypeName)) {
                $itemTypeId = $this->itemTypes->isItemType($accountId, $itemTypeName);
                $itemType = $this->itemTypes->getItemType($accountId, $itemTypeName);
            } else {
                $itemTypeId = (int)$itemTypeName;
                $itemType = $this->itemTypes->getItemTypeById($accountId, $itemTypeId);
                $itemTypeName = $itemType->getName();
            }
            
            //list($filters, $sort) = $this->translateFilterNamesToIds($accountId, $itemType, $filters, $sort);
        } else {
            // If the indices are numeric, then this is a list of Item IDs, otherwise
            // it is a set of field => value pairs, which cannot be used without an
            // itemTypeName to look them up within.
            if(!is_numeric(array_keys($filters)[0])) {
                $filters = [];
            }
            $itemTypeId = false;

            // Cannot sort without itemType
            $sort = [];
        }

        $qb = $this->createQueryBuilder('items');
        $where = $qb->expr()->andX($qb->expr()->eq('items.accountId', $accountId));
        if($itemTypeId) {
            $this->logger->debug(__METHOD__.'items.itemType='.$itemTypeId);
            $where->add($qb->expr()->eq('items.itemType', $itemTypeId));
        }

        $this->addUserFilters($qb, $where, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId, $currentUser);

        $this->logger->debug(__METHOD__.'::filters::'.json_encode($filters));

        if(count($filters) > 0)
        {
            // If the first index is zero, then this is a list of item IDs, not a list of
            // fieldID => value
            $filterItemIds = false;
            foreach(array_keys($filters) as $key) {
                if($key === 0) {
                    $filterItemIds = true;
                }
                break;
            }

            if($filterItemIds) {
                $where->add($qb->expr()->in('items.id', $filters));
            } else {
                $fieldNo = 1;
                foreach($filters as $field => $value)
                {
                    //$fieldName = 'data->"$.'.$field.'"';
                    // TODO: Ensure no security issue with field name injection here
                    //$fieldName = "JSON_EXTRACT(items.itemValues, '$.".preg_replace("/[^A-Za-z0-9]/", '', $field)."')";
                    $fieldName = "JSON_EXTRACT(items.itemValues, :filter".$fieldNo.")";
                    $qb->setParameter('filter'.$fieldNo, '$.'.preg_replace("/[^A-Za-z0-9_]/", '', $field));
                    $fieldNo++;

                    if(substr($value, 0, 4) === "not*") {
                        $value = substr($value, 4, strlen($value)-4);
                        //if(is_numeric($value)) $value = (int)$value;
                        $where->add($qb->expr()->neq($fieldName, $qb->expr()->literal($value)));
                    } else {
                        //if(is_numeric($value)) $value = (int)$value;
                        $where->add($qb->expr()->eq($fieldName, $qb->expr()->literal($value)));
                    }
                }
            }
        }

        if($search) {
            if(is_numeric($search)) {
                $where->add($qb->expr()->eq('items.id', (int)$search));
            } else {
                $where->add($qb->expr()->isNotNull("JSON_SEARCH(items.itemValues, 'one', :searchQuery)"));
                $qb->setParameter('searchQuery', '%'.$search.'%');
            }
        }

        $qb = $qb->where($where);
        if(!$sort) {
            $sort = 'id*desc';
        }

        $sort = $sort;
        $sort = explode('*', $sort);
        if(count($sort) == 1) {
            $qb = $qb->orderby($sort[0]);
        } else {
            if($sort[0] != 'id') {
                $fieldName = "JSON_EXTRACT(items.itemValues, '$.".$sort[0]."')";
            } else {
                $fieldName = 'items.'.$sort[0];
            }
            $qb = $qb->orderby($fieldName, strtoupper($sort[1]) == 'ASC' ? 'ASC' : 'DESC');
        }
        
        $result = $qb->getQuery()->getResult();

        
        $this->logger->debug(__METHOD__.'::result count::'.count($result));

        $this->cache[$cacheKey] = $result;
        return $result;
    }

    /**
     * Fetch list of item titles
     */
    public function fetchItemTitles($accountId, array $itemIds)
    {
        if(!$accountId || !is_array($itemIds) || count($itemIds) == 0 ) 
            throw new \InvalidArgumentException('fetchItemTitles requires accountId, itemIds array');

        $cacheKey = 'fetchItemTitles:'.md5(implode('|', $itemIds).':');
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        $rows = $this->_em->getConnection()
                    ->createQueryBuilder()
                    ->select('i.id', 'i.title', 't.plural_name')
                    ->from('items', 'i')
                    ->innerJoin('i', 'item_types', 't', 't.id = i.item_type_id')
                    ->where('i.id IN (:itemIds)')
                    ->setParameter('itemIds', $itemIds, \Doctrine\DBAL\Connection::PARAM_STR_ARRAY)
                    ->execute()->fetchAll();

        $result = [];
        foreach($rows as $row)
        {
            $result[$row['id']] = $row;
        }

        $this->cache[$cacheKey] = $result;
        return $result;
    }

    /**
     * Takes an array of fieldName => value filters and translates to fieldId => value array
     *
     * @param integer $accountId
     * @param \AppBundle\Entity\ItemType $itemType
     * @param array $filters
     * @return array
     */
    private function translateFilterNamesToIds($accountId, \AppBundle\Entity\ItemType $itemType, array $filters, $sort)
    {
        $cacheKey = 'translateFilterNamesToIds:'.md5($accountId.':'.$itemType->getName().':'.json_encode($filters).':'.$sort);
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        $sort = explode('*', $sort);
        $result = [];
        
        foreach($itemType->getFields() as $field)
        {
            if(array_key_exists($field->getName(), $filters))
            {
                $value = $filters[$field->getName()];
                // TODO: remove hack for status field special values
                if($field->getName() == 'status')
                {
                }
                if($value != 'all') {
                    $result[$field->getId()] = $value;
                }
                
            }
            if($field->getName() == $sort[0])
            {
                $sort[0] = $field->getId();
            }
        }
        
        $this->cache[$cacheKey] = [$result, $sort];
        return [$result, $sort];
    }
    
    /**
     * Get items for an account via itemId
     *
     * @param integer $accountId a user's account id
     * @param $itemId unique ID for an Item
     * @return Item_model
     */
    public function getItem($accountId, $itemId, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId, $ignorePermissions=false)
    {
        // DEBUG $this->logger->debug(__METHOD__.'::params::'.json_encode(['accountId' => $accountId, 'itemId' => $itemId,
        // DEBUG                      'restrictedUserOwnerItemType' => $restrictedUserOwnerItemType, 
        // DEBUG                      'restrictedUserOwnerItemId' => $restrictedUserOwnerItemId,
        // DEBUG                      'ignorePermissions' => $ignorePermissions]));

        if(!$accountId) 
            throw new \InvalidArgumentException('getItem requires accountId');
        if(!$itemId) 
            throw new \InvalidArgumentException('getItem requires itemId');
        if(!is_numeric($restrictedUserOwnerItemType)) 
            throw new \InvalidArgumentException('getItem requires numeric restrictedUserOwnerItemType');
        if(!is_numeric($restrictedUserOwnerItemId)) 
            throw new \InvalidArgumentException('getItem requires numeric restrictedUserOwnerItemId');
        $currentUser = $this->session->getUser();
        if(!$currentUser || !is_object($currentUser))
            throw new \InvalidArgumentException('findItems requires active session');

        $cacheKey = 'getItem:'.md5($accountId.':'.$itemId.':'.$restrictedUserOwnerItemType.':'.
                                   $restrictedUserOwnerItemId.':'.$ignorePermissions.':'.$currentUser->getId());
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        
        $qb = $this->createQueryBuilder('items');

        $where = $qb->expr()->andX($qb->expr()->eq('items.accountId', $accountId));

        $this->addUserFilters($qb, $where, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId, $currentUser);

        $result = $qb->where($where)
                    ->andWhere('items.id = :itemId')
                    ->setParameter('itemId', $itemId)
                    ->getQuery()
                    ->getResult();

        if(count($result) > 0) {
            $item = $result[0];

            // Sanity check on ignorePermissions mode -- it is only valid to use this mode if the user is
            // trying to get their own owner
            if(($restrictedUserOwnerItemType || $restrictedUserOwnerItemId) 
               && $ignorePermissions)
            {
                if($item->getItemType()->getId() != $restrictedUserOwnerItemType
                   || $item->getId() != $restrictedUserOwnerItemId)
                {
                    throw new \InvalidArgumentException("IgnorePermissions used to access an item other than the current user's owner.");
                }
            }
            
        } else {
            throw new \InvalidArgumentException("User does not have access to this item");
        }
        $this->cache[$cacheKey] = $item;
        return $item;
    }

    public function itemInitServiceEntity(Item $item)
    {
        $item->initServiceEntity($this->logger, $this, $this->itemValues, $this->users, $this->fieldMetaFactory, $this->textMacroService);
        return $item;
    }

    public function getUserItem(User $user)
    {
        $userItem = $this->itemInitServiceEntity($user->getUserItem());
        $userItem->onAfterGetItem();
        return $userItem;
    }

    private function standardResultSetMapping()
    {
        $rsm = new ResultSetMappingBuilder($this->_em);
        $rsm->addRootEntityFromClassMetadata('AppBundle\Entity\Item', 'items');
        $rsm->addJoinedEntityFromClassMetadata('AppBundle\Entity\ItemType', 'item_types', 'items', 'itemType',
                                                ['id' => 'item_type_id', 
                                                 'account_id' => 'item_type_account_id', 
                                                 'name' => 'item_type_name',
                                                 'plural_name' => 'item_type_plural_name',
                                                 'label' => 'item_type_label',
                                                 'plural_label' => 'item_type_plural_label',
                                                 'are_users' => 'item_type_are_users',
                                                 'own_users' => 'item_type_own_users']);
        //$rsm->addRootEntityFromClassMetadata('AppBundle\Entity\ItemValue', 'item_values',
        //                                     ['id' => 'value_id', 
        //                                     'account_id' => 'value_account_id',
        //                                     'ver' => 'value_ver']);
        return $rsm;
    }

    /**
     * Create an item. Store its basic properties (item_type_id, etc.) on the items
     * table, and store all extended field values / properties on the item_values
     * table.
     *
     * @param integer $accountId account to create item under
     * @param integer $userId user creating the item
     * @param string $itemTypeName type to store item as
     * @param array of string $item_values extended properties to store for the item
     * @return Item_model
     */
    public function createItem($accountId, $userId, $itemTypeName, $item_values = array(), $restrictedUserOwnerItemType, $restrictedUserOwnerItemId) 
    {
        // DEBUG $this->logger->debug(__METHOD__.'::params::'.json_encode(['accountId' => $accountId, 'itemTypeName' => $itemTypeName,
        // DEBUG                      'restrictedUserOwnerItemType' => $restrictedUserOwnerItemType, 'restrictedUserOwnerItemId' => $restrictedUserOwnerItemId]));
        
        if(!$accountId || !$itemTypeName || !is_numeric($restrictedUserOwnerItemType) || !is_numeric($restrictedUserOwnerItemId)) 
            throw new \InvalidArgumentException('createitem requires accountId, itemTypeName, restrictedUserOwnerItemType and restrictedUserOwnerItemId');


        if($this->itemTypes->isItemType($accountId, $itemTypeName))
        {
            $itemType = $this->itemTypes->getItemType($accountId, $itemTypeName);

            //$this->logger->debug(__METHOD__.'::itemType::'.print_r($itemType, true));

            $item = new Item();
            $item->initServiceEntity($this->logger, $this, $this->itemValues, $this->users, $this->fieldMetaFactory, $this->textMacroService);
            $item->setAccountId($accountId);
            $item->setItemType($itemType);

            foreach($item_values as $field => $value)
            {
                $item->setValue($field, $value);
            }

            
            // DEBUG $this->logger->debug(__METHOD__.'::check if need to prepopulate item for restricted user');
            if($restrictedUserOwnerItemType && $restrictedUserOwnerItemId)
            {
                $fields = $itemType->getFields();
                //$this->logger->debug(__METHOD__.'::fields::'.print_r($fields, true));
                $prepopulatedCount = 0;
                foreach($fields as $field)
                {
                    if($field->getFieldType() == 'Relationship'
                       && $field->getFieldItemType()->getId() == $restrictedUserOwnerItemType) {
                        $item->setValue($field->getName(), $restrictedUserOwnerItemId);
                        $prepopulatedCount++;
                    }
                }
                if($prepopulatedCount == 0) {
                    $this->logger->error(__METHOD__.'::item will not be visible to user, did not find a relationship field to set to their owner!');
                    throw new \Exception('Sorry, we were unable to create an item with the correct permissions.');
                }
            }
            if($item->save(0, $userId, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId)) {
                $itemId = $item->getId();
                // DEBUG $this->logger->debug(__METHOD__.'::load created item '.$itemId);
                $item = $this->getItem($accountId, $itemId, $restrictedUserOwnerItemType, $restrictedUserOwnerItemId);
                return $item;
            }
        }

        return false;
    }

    /**
     * Create an item used to render filters.
     */
    public function createFilterItem($accountId, $itemTypeName)
    {
        if($this->itemTypes->isItemType($accountId, $itemTypeName))
        {
            $itemType = $this->itemTypes->getItemType($accountId, $itemTypeName);

            $filterItem = new Item();
            $filterItem->initServiceEntity($this->logger, $this, $this->itemValues, $this->users, $this->fieldMetaFactory, $this->textMacroService);
            $filterItem->setAccountId($accountId);
            $filterItem->setItemType($itemType);

            return $filterItem;
        }

        return false;
        
    }

    /**
     * Helper to save item
     */
    public function saveItem(Item $item)
    {
        if(!$item->getId()) {
           $this->getEntityManager()->persist($item);
        }
        $this->getEntityManager()->flush();
        $this->clearCache();
        $this->itemValues->clearCache();
        return $item->getId();
    }
    
}

<?php

/*
 * @package ArionCRM
 * @author Isaac Raway <iraway@metasushi [dot] com>
 * @author Antoinette Smith <asmith@metasushi [dot] com>
 * @link http://arioncrm.com/
 * @copyright (c)2015-2022. MetaSushi, LLC. All rights reserved. Your use of this software in any way indicates agreement
 * to the software license available currenty at http://arioncrm.com/ 
 * This open source edition is released under GPL 3.0. available at https://www.gnu.org/licenses/gpl-3.0.en.html
 */

namespace AppBundle\Service;

// Framework
use Symfony\Component\Routing\RouterInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

// Project
use AppBundle\Service\AuthService;
use AppBundle\Entity\ItemRepository;
use AppBundle\Entity\MailboxMessageRepository;

class TextMacroService extends \Twig_Extension {

    /**
     * @var \Psr\Log\LoggerInterface $logger
     */
    protected $logger;

    /**
     * @var \Symfony\Component\Routing\RouterInterface
     */
    protected $router;

    /**
     * @var \AppBundle\Service\AuthService
     */
    protected $authService;

    /**
     * @var \AppBundle\Entity\ItemRepository
     */
    protected $items;

    /**
     * @var \AppBundle\Service\SiteService
     */
    protected $site;

    private $accountId;
    private $userId;
    private $restrictedUserOwnerItemType;
    private $restrictedUserOwnerItemId;

    private $cache = [];

    public function __construct(\Psr\Log\LoggerInterface $logger,
                                RouterInterface $router,
                                AuthService $authService,
                                ItemRepository $items,
                                AutolinkService $autoLinkService,
                                SiteService $siteService) {
        $this->logger = $logger;
        $this->router = $router;
        $this->authService = $authService;
        $this->items = $items;
        $this->autoLinkService = $autoLinkService;
        $this->site = $siteService;
        $this->items->setMacroService($this);
    }

    /**
     * Return list of filters to Twig
     *
     * @return array
     */
    public function getFilters()
    {
        return [
            new \Twig_SimpleFilter('processMacros', [$this, 'processMacros']),
            new \Twig_SimpleFilter('purify', [$this, 'purify'], ['is_safe' => ['html']]),
            new \Twig_SimpleFilter('fileShouldBeDownloaded', [$this, 'fileShouldBeDownloaded']),
        ];
    }

    /**
     * Return a name to Twig
     */
    public function getName()
    {
        return 'macros';
    }

    /**
     * Public filter to process all available macro syntax types.
     *
     * @param $string to process
     * @return processsed string
     */
    public function processMacros($string) {
        $cacheKey = 'processMacros:'.md5($string.':');
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        $tokens = [];

        // Protect any existing anchor tags
        if(preg_match_all('#<a(.*)</a>#', $string, $matches))
        {
            foreach($matches[0] as $match)
            {
                $token = "__ANCHOR__".md5($match)."__";
                $tokens[$token] = $match;
                $string = str_replace($match, $token, $string);
            }
        }
        

        $baseUrl = $this->router->generate('home', [], UrlGeneratorInterface::ABSOLUTE_URL);
        
        // Protect indented code snippets and [code]...[/code] blocks
        $lines = explode("\n", $string);
        $state = 0;
        foreach($lines as $line => $lineString)
        {
            switch($state)
            {
                case 0:
                    if(substr($lineString, 0, 12) == "&nbsp;&nbsp;" || substr($lineString, 0, 4) == "    ") { 
                        $token = "__CODE__".md5($lineString)."__";
                        $tokens[$token] = htmlspecialchars($lineString);
                        $lines[$line] = $token;
                    }
                    if(trim(strip_tags($lineString)) == '[code]') {
                        $mode = 1;
                    }
                    break;
                case 1: // [code]
                    if(trim(strip_tags($lineString)) == '[/code]') {
                        $mode = 0;
                    } else {
                        $token = "__CODE__".md5($lineString)."__";
                        $tokens[$token] = htmlspecialchars($lineString);
                        $lines[$line] = $token;
                    }
                    break;
            }
        }
        $string = implode("\n", $lines);

        $string = $this->processItemLinks($string);
        // Replace our baseUrl (e.x. https://tickets.metasushi.com/) with a token so that Twitter_Autolink
        // won't mangle URLs generated by processItemLinks
        $string = str_replace($baseUrl, '__MARK__BASE__91dfe9d16f586488042bbf1320db22da__', $string);

        // Disable Twitter_Autolink's username linking by changing at signs to a token
        $string = str_replace('@', '__MARK__AT__82d54eb64ef8e08584ccf03166b3dba0__', $string);


        $string = $this->autoLinkService->create()->autolink($string);

        // Replace tokens with real values
        foreach($tokens as $token => $value)
        {
            $string = str_replace($token, $value, $string);
        }

        $string = str_replace('__MARK__AT__82d54eb64ef8e08584ccf03166b3dba0__', '@', $string);
        $string = str_replace('__MARK__BASE__91dfe9d16f586488042bbf1320db22da__', $baseUrl, $string);
        
        $this->cache[$cacheKey] = $string;
        return $this->cache[$cacheKey];
    }

    /**
     * Internal processing function for item links in the format #12345
     * For now, we only process a link if it starts with a hash AND has 4 or 5 numbers.
     *
     * @param $string to process
     * @return processsed string with links
     */
    private function processItemLinks($string) {
        $cacheKey = 'processItemLinks:'.md5($string.':');
        if(isset($this->cache[$cacheKey])) return $this->cache[$cacheKey];

        // Because this is a twig extension, we cannot make authService calls until we're actually processing a
        // real macro request -- no authService calls can go into the constructor.
        $this->accountId = $this->authService->getAccountId();
        $this->userId = $this->authService->getUserId();

        list($this->restrictedUserOwnerItemType, $this->restrictedUserOwnerItemId) = $this->authService->getRestrictedUserKey($this->accountId, $this->userId);

        if(preg_match_all('/#(\d{4,5})/', $string, $matches)) {
            // Sort IDs based on longest first so that we do not do partial string replacements
            usort($matches[1], [$this,'lenSort']);

            // Build list of item IDs to load info for all at once
            $itemIds = [];
            foreach($matches[1] as $match) {
                $itemIds[] = (int)$match;

                // Stop after an unreasonable number of links
                if(count($itemIds) > 50) break;
            }

            // Load items so we can build a list of itemTypes to be used in links
            /*
            ($accountId, $itemTypeName, array $filters=[], $search, $sort,
            $restrictedUserOwnerItemType, $restrictedUserOwnerItemId)
            */
            $this->logger->debug(__METHOD__.'::call findItems');
            $rs = $this->items->findItems($this->accountId, '', $itemIds, '', '',
                                             $this->restrictedUserOwnerItemType, $this->restrictedUserOwnerItemId, false, false);

            // Build list of itemTypes indexed by itemId
            $items = [];
            foreach($rs as $item) {
                $items[$item->getId()] = $item;
            }

            // Replace IDs in the string with links to each item
            foreach($matches[1] as $match) {
                $itemId = (int)$match;
                if(array_key_exists($itemId, $items)) {
                    $item = $items[$itemId];
                    $url = $this->router->generate('items',
                                ['itemType' => $items[$itemId]->getItemType()->getPluralName()],
                                UrlGeneratorInterface::ABSOLUTE_URL).
                                '?id='.$itemId;

                    // Remove the title if it was already after the item ID
                    $string = str_replace('#'.$match.': '.$item->getTitle(), '#'.$match, $string);
                    $string = str_replace('#'.$match.' '.$item->getTitle(), '#'.$match, $string);

                    // Add link with item ID and title as caption
                    $string = str_replace('#'.$match, '<a href="'.$url.'">#'.$match.': '.$item->getTitle().'</a>', $string);
                }
            }
        }

        $this->cache[$cacheKey] = $string;
        return $this->cache[$cacheKey];
    }

    private function lenSort($a,$b){
        return strlen($b)-strlen($a);
    }

    /**
     * Public filter to process string with HTMLPUrifier.
     *
     * @param $string to process
     * @param $allowConflictFlags if true, conflict classes will not be stripped
     * @return processsed string
     */
    public function purify($string, $allowConflictFlags=false) {
        return $this->site->purify($string, $allowConflictFlags);
    }
    public function truncateEmailAndPurify($string, $emailFromName=false) {
        return $this->site->truncateEmailAndPurify($string, $emailFromName);
    }

    public function fileShouldBeDownloaded($string) {
        $info = new \SplFileInfo($string);
        return !in_array(strtolower($info->getExtension()), ['jpg', 'jpeg', 'gif', 'pdf', 'png']);
    }
}
